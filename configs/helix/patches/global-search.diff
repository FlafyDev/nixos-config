diff --git a/helix-term/src/commands.rs b/helix-term/src/commands.rs
index 7e4969c1a7f..f70f9246f15 100644
--- a/helix-term/src/commands.rs
+++ b/helix-term/src/commands.rs
@@ -49,11 +49,11 @@ use crate::{
     compositor::{self, Component, Compositor},
     job::Callback,
     keymap::ReverseKeymap,
-    ui::{self, overlay::overlayed, FilePicker, Picker, Popup, Prompt, PromptEvent},
+    ui::{self, overlay::overlayed, DynamicPicker, FilePicker, Picker, Popup, Prompt, PromptEvent},
 };
 
 use crate::job::{self, Jobs};
-use futures_util::StreamExt;
+use futures_util::{FutureExt, StreamExt};
 use std::{collections::HashMap, fmt, fmt::Write, future::Future};
 use std::{collections::HashSet, num::NonZeroUsize};
 
@@ -1811,13 +1811,15 @@ fn global_search(cx: &mut Context) {
         path: PathBuf,
         /// 0 indexed lines
         line_num: usize,
+        line_content: String,
     }
 
     impl FileResult {
-        fn new(path: &Path, line_num: usize) -> Self {
+        fn new(path: &Path, line_num: usize, line_content: String) -> Self {
             Self {
                 path: path.to_path_buf(),
                 line_num,
+                line_content,
             }
         }
     }
@@ -1829,158 +1831,166 @@ fn global_search(cx: &mut Context) {
             let relative_path = helix_core::path::get_relative_path(&self.path)
                 .to_string_lossy()
                 .into_owned();
-            if current_path
+
+            let is_current = current_path
                 .as_ref()
                 .map(|p| p == &self.path)
-                .unwrap_or(false)
-            {
-                format!("{} (*)", relative_path).into()
-            } else {
-                relative_path.into()
-            }
+                .unwrap_or(false);
+
+            format!(
+                "{}:{}{}",
+                relative_path,
+                self.line_num,
+                if is_current { " (*)" } else { "" }
+            )
+            .into()
+        }
+
+        fn sort_text(&self, _current_path: &Self::Data) -> Cow<str> {
+            Cow::Borrowed(&self.line_content)
+        }
+
+        fn filter_text(&self, _current_path: &Self::Data) -> Cow<str> {
+            Cow::Borrowed(&self.line_content)
         }
     }
 
-    let (all_matches_sx, all_matches_rx) = tokio::sync::mpsc::unbounded_channel::<FileResult>();
     let config = cx.editor.config();
     let smart_case = config.search.smart_case;
     let file_picker_config = config.file_picker.clone();
 
-    let reg = cx.register.unwrap_or('/');
+    let current_path = doc_mut!(cx.editor).path().cloned();
 
-    let completions = search_completions(cx, Some(reg));
-    ui::regex_prompt(
-        cx,
-        "global-search:".into(),
-        Some(reg),
-        move |_editor: &Editor, input: &str| {
-            completions
-                .iter()
-                .filter(|comp| comp.starts_with(input))
-                .map(|comp| (0.., std::borrow::Cow::Owned(comp.clone())))
-                .collect()
-        },
-        move |_editor, regex, event| {
-            if event != PromptEvent::Validate {
-                return;
+    let mut picker = FilePicker::new(
+        Vec::new(),
+        current_path,
+        move |cx, FileResult { path, line_num, .. }, action| {
+            match cx.editor.open(path, action) {
+                Ok(_) => {}
+                Err(e) => {
+                    cx.editor
+                        .set_error(format!("Failed to open file '{}': {}", path.display(), e));
+                    return;
+                }
             }
 
-            if let Ok(matcher) = RegexMatcherBuilder::new()
-                .case_smart(smart_case)
-                .build(regex.as_str())
-            {
-                let searcher = SearcherBuilder::new()
-                    .binary_detection(BinaryDetection::quit(b'\x00'))
-                    .build();
-
-                let search_root = std::env::current_dir()
-                    .expect("Global search error: Failed to get current dir");
-                WalkBuilder::new(search_root)
-                    .hidden(file_picker_config.hidden)
-                    .parents(file_picker_config.parents)
-                    .ignore(file_picker_config.ignore)
-                    .follow_links(file_picker_config.follow_symlinks)
-                    .git_ignore(file_picker_config.git_ignore)
-                    .git_global(file_picker_config.git_global)
-                    .git_exclude(file_picker_config.git_exclude)
-                    .max_depth(file_picker_config.max_depth)
-                    // We always want to ignore the .git directory, otherwise if
-                    // `ignore` is turned off above, we end up with a lot of noise
-                    // in our picker.
-                    .filter_entry(|entry| entry.file_name() != ".git")
-                    .build_parallel()
-                    .run(|| {
-                        let mut searcher = searcher.clone();
-                        let matcher = matcher.clone();
-                        let all_matches_sx = all_matches_sx.clone();
-                        Box::new(move |entry: Result<DirEntry, ignore::Error>| -> WalkState {
-                            let entry = match entry {
-                                Ok(entry) => entry,
-                                Err(_) => return WalkState::Continue,
-                            };
-
-                            match entry.file_type() {
-                                Some(entry) if entry.is_file() => {}
-                                // skip everything else
-                                _ => return WalkState::Continue,
-                            };
-
-                            let result = searcher.search_path(
-                                &matcher,
-                                entry.path(),
-                                sinks::UTF8(|line_num, _| {
-                                    all_matches_sx
-                                        .send(FileResult::new(entry.path(), line_num as usize - 1))
-                                        .unwrap();
-
-                                    Ok(true)
-                                }),
-                            );
-
-                            if let Err(err) = result {
-                                log::error!(
-                                    "Global search error: {}, {}",
-                                    entry.path().display(),
-                                    err
-                                );
-                            }
-                            WalkState::Continue
-                        })
-                    });
-            } else {
-                // Otherwise do nothing
-                // log::warn!("Global Search Invalid Pattern")
-            }
+            let line_num = *line_num;
+            let (view, doc) = current!(cx.editor);
+            let text = doc.text();
+            let start = text.line_to_char(line_num);
+            let end = text.line_to_char((line_num + 1).min(text.len_lines()));
+
+            doc.set_selection(view.id, Selection::single(start, end));
+            align_view(doc, view, Align::Center);
+        },
+        |_editor, FileResult { path, line_num, .. }| {
+            Some((path.clone(), Some((*line_num, *line_num))))
         },
     );
 
-    let current_path = doc_mut!(cx.editor).path().cloned();
+    if let Some(initial_query) = cx.editor.registers.last(cx.register.unwrap_or('/')) {
+        picker = picker.with_line(initial_query.clone(), cx.editor);
+    }
 
-    let show_picker = async move {
-        let all_matches: Vec<FileResult> =
-            UnboundedReceiverStream::new(all_matches_rx).collect().await;
-        let call: job::Callback = Callback::EditorCompositor(Box::new(
-            move |editor: &mut Editor, compositor: &mut Compositor| {
-                if all_matches.is_empty() {
-                    editor.set_status("No matches found");
-                    return;
-                }
+    let get_files = move |query: String, cx: &mut compositor::Context| {
+        // Show empty results for an empty query.
+        if query.is_empty() {
+            return async move { Ok(Vec::new()) }.boxed();
+        }
 
-                let picker = FilePicker::new(
-                    all_matches,
-                    current_path,
-                    move |cx, FileResult { path, line_num }, action| {
-                        match cx.editor.open(path, action) {
-                            Ok(_) => {}
-                            Err(e) => {
-                                cx.editor.set_error(format!(
-                                    "Failed to open file '{}': {}",
-                                    path.display(),
-                                    e
-                                ));
-                                return;
-                            }
-                        }
+        let (all_matches_sx, all_matches_rx) = tokio::sync::mpsc::unbounded_channel::<FileResult>();
 
-                        let line_num = *line_num;
-                        let (view, doc) = current!(cx.editor);
-                        let text = doc.text();
-                        let start = text.line_to_char(line_num);
-                        let end = text.line_to_char((line_num + 1).min(text.len_lines()));
-
-                        doc.set_selection(view.id, Selection::single(start, end));
-                        align_view(doc, view, Align::Center);
-                    },
-                    |_editor, FileResult { path, line_num }| {
-                        Some((path.clone(), Some((*line_num, *line_num))))
-                    },
-                );
-                compositor.push(Box::new(overlayed(picker)));
-            },
-        ));
-        Ok(call)
+        let matcher = match RegexMatcherBuilder::new()
+            .case_smart(smart_case)
+            .build(&query)
+        {
+            Ok(matcher) => matcher,
+            Err(err) => {
+                cx.jobs.callback(async {
+                    let callback =
+                        Callback::EditorCompositor(Box::new(move |_editor, compositor| {
+                            let contents = ui::Text::new(format!("{}", err));
+                            let size = compositor.size();
+                            let mut popup = Popup::new("invalid-regex", contents)
+                                .position(Some(Position::new(size.height as usize - 2, 0)))
+                                .auto_close(true);
+                            popup.required_size((size.width, size.height));
+                            compositor.replace_or_push("invalid-regex", popup);
+                        }));
+                    Ok(callback)
+                });
+                return async move { Err(anyhow::anyhow!("Failed to compile regex")) }.boxed();
+            }
+        };
+
+        let searcher = SearcherBuilder::new()
+            .binary_detection(BinaryDetection::quit(b'\x00'))
+            .build();
+
+        let search_root =
+            std::env::current_dir().expect("Global search error: Failed to get current dir");
+        WalkBuilder::new(search_root)
+            .hidden(file_picker_config.hidden)
+            .parents(file_picker_config.parents)
+            .ignore(file_picker_config.ignore)
+            .follow_links(file_picker_config.follow_symlinks)
+            .git_ignore(file_picker_config.git_ignore)
+            .git_global(file_picker_config.git_global)
+            .git_exclude(file_picker_config.git_exclude)
+            .max_depth(file_picker_config.max_depth)
+            // We always want to ignore the .git directory, otherwise if
+            // `ignore` is turned off above, we end up with a lot of noise
+            // in our picker.
+            .filter_entry(|entry| entry.file_name() != ".git")
+            .build_parallel()
+            .run(|| {
+                let mut searcher = searcher.clone();
+                let matcher = matcher.clone();
+                let all_matches_sx = all_matches_sx.clone();
+                Box::new(move |entry: Result<DirEntry, ignore::Error>| -> WalkState {
+                    let entry = match entry {
+                        Ok(entry) => entry,
+                        Err(_) => return WalkState::Continue,
+                    };
+
+                    match entry.file_type() {
+                        Some(entry) if entry.is_file() => {}
+                        // skip everything else
+                        _ => return WalkState::Continue,
+                    };
+
+                    let result = searcher.search_path(
+                        &matcher,
+                        entry.path(),
+                        sinks::UTF8(|line_num, line_content| {
+                            all_matches_sx
+                                .send(FileResult::new(
+                                    entry.path(),
+                                    line_num as usize - 1,
+                                    line_content.to_string(),
+                                ))
+                                .unwrap();
+
+                            Ok(true)
+                        }),
+                    );
+
+                    if let Err(err) = result {
+                        log::error!("Global search error: {}, {}", entry.path().display(), err);
+                    }
+                    WalkState::Continue
+                })
+            });
+
+        async move {
+            let all_matches: Vec<FileResult> =
+                UnboundedReceiverStream::new(all_matches_rx).collect().await;
+            Ok(all_matches)
+        }
+        .boxed()
     };
-    cx.jobs.callback(show_picker);
+    let dyn_picker = DynamicPicker::new(picker, Box::new(get_files));
+    cx.push_layer(Box::new(overlayed(dyn_picker)));
 }
 
 enum Extend {
diff --git a/helix-term/src/commands/lsp.rs b/helix-term/src/commands/lsp.rs
index c149e62b40b..1578aedd989 100644
--- a/helix-term/src/commands/lsp.rs
+++ b/helix-term/src/commands/lsp.rs
@@ -1,3 +1,4 @@
+use futures_util::FutureExt;
 use helix_lsp::{
     block_on,
     lsp::{self, CodeAction, CodeActionOrCommand, DiagnosticSeverity, NumberOrString},
@@ -14,7 +15,8 @@ use helix_view::{apply_transaction, document::Mode, editor::Action, theme::Style
 use crate::{
     compositor::{self, Compositor},
     ui::{
-        self, lsp::SignatureHelp, overlay::overlayed, FileLocation, FilePicker, Popup, PromptEvent,
+        self, lsp::SignatureHelp, overlay::overlayed, DynamicPicker, FileLocation, FilePicker,
+        Popup, PromptEvent,
     },
 };
 
@@ -370,10 +372,36 @@ pub fn workspace_symbol_picker(cx: &mut Context) {
     cx.callback(
         future,
         move |_editor, compositor, response: Option<Vec<lsp::SymbolInformation>>| {
-            if let Some(symbols) = response {
-                let picker = sym_picker(symbols, current_url, offset_encoding);
-                compositor.push(Box::new(overlayed(picker)))
-            }
+            let symbols = match response {
+                Some(s) => s,
+                None => return,
+            };
+            let picker = sym_picker(symbols, current_url, offset_encoding);
+            let get_symbols = |query: String, cx: &mut compositor::Context| {
+                let doc = doc!(cx.editor);
+                let language_server = match doc.language_server() {
+                    Some(s) => s,
+                    None => {
+                        // This should not generally happen since the picker will not
+                        // even open in the first place if there is no server.
+                        return async move { Err(anyhow::anyhow!("LSP not active")) }.boxed();
+                    }
+                };
+                let symbol_request = language_server.workspace_symbols(query);
+
+                let future = async move {
+                    let json = symbol_request.await?;
+                    let response: Option<Vec<lsp::SymbolInformation>> =
+                        serde_json::from_value(json)?;
+
+                    response.ok_or_else(|| {
+                        anyhow::anyhow!("No response for workspace symbols from language server")
+                    })
+                };
+                future.boxed()
+            };
+            let dyn_picker = DynamicPicker::new(picker, Box::new(get_symbols));
+            compositor.push(Box::new(overlayed(dyn_picker)))
         },
     )
 }
diff --git a/helix-term/src/ui/mod.rs b/helix-term/src/ui/mod.rs
index cca9e9bf0b6..b4e66777c88 100644
--- a/helix-term/src/ui/mod.rs
+++ b/helix-term/src/ui/mod.rs
@@ -19,7 +19,7 @@ pub use completion::Completion;
 pub use editor::EditorView;
 pub use markdown::Markdown;
 pub use menu::Menu;
-pub use picker::{FileLocation, FilePicker, Picker};
+pub use picker::{DynamicPicker, FileLocation, FilePicker, Picker};
 pub use popup::Popup;
 pub use prompt::{Prompt, PromptEvent};
 pub use spinner::{ProgressSpinners, Spinner};
diff --git a/helix-term/src/ui/overlay.rs b/helix-term/src/ui/overlay.rs
index 0b8a93ae833..5b2bc806093 100644
--- a/helix-term/src/ui/overlay.rs
+++ b/helix-term/src/ui/overlay.rs
@@ -69,4 +69,8 @@ impl<T: Component + 'static> Component for Overlay<T> {
         let dimensions = (self.calc_child_size)(area);
         self.content.cursor(dimensions, ctx)
     }
+
+    fn id(&self) -> Option<&'static str> {
+        self.content.id()
+    }
 }
diff --git a/helix-term/src/ui/picker.rs b/helix-term/src/ui/picker.rs
index 2505f21972e..44d2c37d18e 100644
--- a/helix-term/src/ui/picker.rs
+++ b/helix-term/src/ui/picker.rs
@@ -3,6 +3,7 @@ use crate::{
     ctrl, key, shift,
     ui::{self, fuzzy_match::FuzzyQuery, EditorView},
 };
+use futures_util::future::BoxFuture;
 use tui::{
     buffer::Buffer as Surface,
     widgets::{Block, BorderType, Borders},
@@ -27,7 +28,7 @@ use helix_view::{
     Document, Editor,
 };
 
-use super::menu::Item;
+use super::{menu::Item, overlay::Overlay};
 
 pub const MIN_AREA_WIDTH_FOR_PREVIEW: u16 = 72;
 /// Biggest file size to preview in bytes
@@ -109,6 +110,11 @@ impl<T: Item> FilePicker<T> {
         self
     }
 
+    pub fn with_line(mut self, line: String, editor: &Editor) -> Self {
+        self.picker.set_line(line, editor);
+        self
+    }
+
     fn current_file(&self, editor: &Editor) -> Option<FileLocation> {
         self.picker
             .selection()
@@ -411,31 +417,38 @@ impl<T: Item> Picker<T> {
             self.matches
                 .sort_unstable_by_key(|(_, score)| Reverse(*score));
         } else {
-            let query = FuzzyQuery::new(pattern);
-            self.matches.clear();
-            self.matches.extend(
-                self.options
-                    .iter()
-                    .enumerate()
-                    .filter_map(|(index, option)| {
-                        let text = option.filter_text(&self.editor_data);
-
-                        query
-                            .fuzzy_match(&text, &self.matcher)
-                            .map(|score| (index, score))
-                    }),
-            );
-            self.matches
-                .sort_unstable_by_key(|(_, score)| Reverse(*score));
+            self.force_score();
         }
 
         log::debug!("picker score {:?}", Instant::now().duration_since(now));
 
         // reset cursor position
         self.cursor = 0;
+        let pattern = self.prompt.line();
         self.previous_pattern.clone_from(pattern);
     }
 
+    pub fn force_score(&mut self) {
+        let pattern = self.prompt.line();
+
+        let query = FuzzyQuery::new(pattern);
+        self.matches.clear();
+        self.matches.extend(
+            self.options
+                .iter()
+                .enumerate()
+                .filter_map(|(index, option)| {
+                    let text = option.filter_text(&self.editor_data);
+
+                    query
+                        .fuzzy_match(&text, &self.matcher)
+                        .map(|score| (index, score))
+                }),
+        );
+        self.matches
+            .sort_unstable_by_key(|(_, score)| Reverse(*score));
+    }
+
     /// Move the cursor by a number of lines, either down (`Forward`) or up (`Backward`)
     pub fn move_by(&mut self, amount: usize, direction: Direction) {
         let len = self.matches.len();
@@ -492,6 +505,10 @@ impl<T: Item> Picker<T> {
         }
         EventResult::Consumed(None)
     }
+
+    pub fn set_line(&mut self, line: String, editor: &Editor) {
+        self.prompt.set_line(line, editor);
+    }
 }
 
 // process:
@@ -683,3 +700,77 @@ impl<T: Item + 'static> Component for Picker<T> {
         self.prompt.cursor(area, editor)
     }
 }
+
+/// Returns a new list of options to replace the contents of the picker
+/// when called with the current picker query,
+pub type DynQueryCallback<T> =
+    Box<dyn Fn(String, &mut Context) -> BoxFuture<'static, anyhow::Result<Vec<T>>>>;
+
+/// A picker that updates its contents via a callback whenever the
+/// query string changes. Useful for live grep, workspace symbols, etc.
+pub struct DynamicPicker<T: ui::menu::Item + Send> {
+    file_picker: FilePicker<T>,
+    query_callback: DynQueryCallback<T>,
+    query: String,
+}
+
+impl<T: ui::menu::Item + Send> DynamicPicker<T> {
+    pub const ID: &'static str = "dynamic-picker";
+
+    pub fn new(file_picker: FilePicker<T>, query_callback: DynQueryCallback<T>) -> Self {
+        Self {
+            file_picker,
+            query_callback,
+            query: String::new(),
+        }
+    }
+}
+
+impl<T: Item + Send + 'static> Component for DynamicPicker<T> {
+    fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
+        self.file_picker.render(area, surface, cx);
+    }
+
+    fn handle_event(&mut self, event: &Event, cx: &mut Context) -> EventResult {
+        let event_result = self.file_picker.handle_event(event, cx);
+        let current_query = self.file_picker.picker.prompt.line();
+
+        if !matches!(event, Event::IdleTimeout) || self.query == *current_query {
+            return event_result;
+        }
+
+        self.query.clone_from(current_query);
+
+        let new_options = (self.query_callback)(current_query.to_owned(), cx);
+
+        cx.jobs.callback(async move {
+            let new_options = new_options.await?;
+            let callback =
+                crate::job::Callback::EditorCompositor(Box::new(move |_editor, compositor| {
+                    // Wrapping of pickers in overlay is done outside the picker code,
+                    // so this is fragile and will break if wrapped in some other widget.
+                    let picker = match compositor.find_id::<Overlay<DynamicPicker<T>>>(Self::ID) {
+                        Some(overlay) => &mut overlay.content.file_picker.picker,
+                        None => return,
+                    };
+                    picker.options = new_options;
+                    picker.cursor = 0;
+                    picker.force_score();
+                }));
+            anyhow::Ok(callback)
+        });
+        EventResult::Consumed(None)
+    }
+
+    fn cursor(&self, area: Rect, ctx: &Editor) -> (Option<Position>, CursorKind) {
+        self.file_picker.cursor(area, ctx)
+    }
+
+    fn required_size(&mut self, viewport: (u16, u16)) -> Option<(u16, u16)> {
+        self.file_picker.required_size(viewport)
+    }
+
+    fn id(&self) -> Option<&'static str> {
+        Some(Self::ID)
+    }
+}
diff --git a/helix-term/src/ui/prompt.rs b/helix-term/src/ui/prompt.rs
index 51ef688d764..a6bb831b2b8 100644
--- a/helix-term/src/ui/prompt.rs
+++ b/helix-term/src/ui/prompt.rs
@@ -84,11 +84,15 @@ impl Prompt {
     }
 
     pub fn with_line(mut self, line: String, editor: &Editor) -> Self {
+        self.set_line(line, editor);
+        self
+    }
+
+    pub fn set_line(&mut self, line: String, editor: &Editor) {
         let cursor = line.len();
         self.line = line;
         self.cursor = cursor;
         self.recalculate_completion(editor);
-        self
     }
 
     pub fn line(&self) -> &String {
